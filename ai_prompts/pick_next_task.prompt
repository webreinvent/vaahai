# Pick Next Task Prompt for VaahAI

You are an AI assistant helping with the VaahAI project, a multi-agent AI CLI tool built with Microsoft's Autogen Framework.

## WORKFLOW
Follow this complete workflow for task management and implementation:

### 1. Verify Previous Task Completion
- Review the code changes for the previous task
- Run appropriate tests to verify functionality
- Check that all acceptance criteria have been met
- Confirm that the implementation aligns with the project architecture
- If the task is incomplete, identify what remains to be done before proceeding

### 2. Update Documentation
- Update relevant documents in `/specs`, `/docs`, and `/ai_docs`
- Ensure implementation details are documented
- Update API documentation if applicable
- Add usage examples where appropriate
- Ensure the documentation reflects the current implementation

### 3. Create Git Commit
- Summarize the changes made for the previous task
- Include relevant task IDs in the commit message
- Describe the functionality that was implemented
- Note any architectural decisions made
- Create a commit with a clear, descriptive message

### 4. Create Merge/Pull Request
- Create a merge/pull request from the current branch to the `develop` branch
- Include a descriptive title that references the task ID
- Add a detailed description of the changes made
- Reference any related issues or tasks
- Request appropriate reviewers if applicable
- Add relevant labels and milestones

### 5. Select Next Task
- Review the current project status in `/specs/TASK_TRACKING.md`
- Identify tasks marked as "Not Started" that have no incomplete dependencies
- Prioritize MVP tasks and those that unblock multiple other tasks
- Consider the logical flow of implementation
- Update the task status in `TASK_TRACKING.md` to "In Progress"

### 6. Create New Branch
- PREFERRED APPROACH: Create a branch from the previous task branch if it contains necessary code for the next task
  - First ensure you're on the previous task branch
  - Pull any recent changes from the develop branch: `git pull origin develop`
  - Create a new branch: `git checkout -b feature/P<phase>-task-<id>-<description>`
- ALTERNATIVE APPROACH: If previous task branch is not suitable, create branch from develop
  - First checkout develop: `git checkout develop`
  - Pull latest changes: `git pull origin develop`
  - Create a new branch: `git checkout -b feature/P<phase>-task-<id>-<description>`
- Always follow the project's branch naming conventions
- Push the branch to the remote repository

### 7. Understand Task Scope
- Read the task description thoroughly
- Review related documentation and requirements
- Understand how this task fits into the overall project
- Identify the specific deliverables for this task
- Define clear acceptance criteria

### 8. Create Implementation Plan
- Break down the task into smaller steps
- Identify the files that need to be created or modified
- Determine the classes, functions, and interfaces required
- Consider edge cases and error handling
- Plan for testing and validation
- Present the plan for confirmation before proceeding

### 9. Implement the Task
- Follow the confirmed implementation plan
- Write clean, well-documented code
- Adhere to the project's coding guidelines:
  - Create small, focused files with single responsibilities
  - Keep methods short (under 30-50 lines)
  - Apply appropriate design patterns (Singleton, Factory, Adapter, etc.)
  - Follow SOLID principles
  - Use dependency injection for better testability
- Implement comprehensive unit tests
- Ensure the code integrates well with existing components

## TASK SELECTION CRITERIA
When selecting the next task, consider:

1. **Dependencies**: Tasks with all dependencies satisfied
2. **MVP Priority**: Tasks that are part of the defined MVP
3. **Unblocking Value**: Tasks that unblock multiple other tasks if completed
4. **Phase Alignment**: Tasks that align with the current phase of development
5. **Strategic Importance**: Tasks critical to project progress
6. **Complexity and Effort**: Balance between quick wins and strategic progress
7. **Technical Risk**: Address high-risk items early when possible
8. **Logical Flow**: Follow a natural development sequence

## OUTPUT FORMAT
Provide a comprehensive response with the following structure:

1. **Previous Task Verification**:
   - Status of the previous task (Complete/Incomplete)
   - Test results and verification details
   - Any outstanding issues

2. **Documentation Updates**:
   - Summary of documentation changes made
   - Files updated and why

3. **Git Commit Details**:
   - Commit message
   - Files included in the commit
   - Branch information

4. **Merge/Pull Request Details**:
   - Title and description of the merge/pull request
   - Reference to related issues or tasks
   - Reviewers requested

5. **Next Task Selection**:
   - Recommended task(s) to work on next, in priority order
   - Justification for each task
   - Dependencies that have been satisfied
   - Task tracking updates made

6. **New Branch Creation**:
   - Branch name
   - Base branch
   - Creation confirmation

7. **Task Scope Analysis**:
   - Detailed understanding of the task
   - Deliverables and acceptance criteria
   - Relationship to other components

8. **Implementation Plan**:
   - Step-by-step approach
   - Files to be created or modified
   - Classes, functions, and interfaces required
   - Testing strategy
   - Request for confirmation

9. **Implementation Execution** (after confirmation):
   - Code implementation details following the coding guidelines
   - Application of appropriate design patterns
   - Proper file organization and method design
   - Testing results and coverage metrics
   - Integration notes and performance considerations

## IMPORTANT NOTES
- Focus on incremental development with small, achievable tasks
- Prioritize Autogen framework integration as a foundational component
- Maintain clear dependencies between tasks
- Enable frequent small releases
- Ensure thorough documentation at each step
- Follow test-driven development practices where appropriate
- Commit early and often with clear messages

## CODING GUIDELINES
Follow these coding guidelines for all implementations:

### 1. File Organization
- Keep files small and focused on a single responsibility
- Split large modules into multiple files with clear separation of concerns
- Aim for files under 300-400 lines of code
- Use appropriate directory structure to organize related files
- Create separate files for interfaces, implementations, and utilities

### 2. Method and Function Design
- Keep methods short and focused on a single task
- Aim for methods under 30-50 lines of code
- Follow the Single Responsibility Principle
- Use descriptive method names that clearly indicate their purpose
- Limit the number of parameters (preferably 5 or fewer)
- Use type hints consistently for better code readability

### 3. Class Design
- Follow the SOLID principles
- Keep classes focused on a single responsibility
- Prefer composition over inheritance
- Use abstract base classes and interfaces to define contracts
- Implement design patterns appropriately:
  - Singleton for classes that should have only one instance
  - Factory for object creation
  - Adapter for interfacing with external libraries
  - Strategy for interchangeable algorithms
  - Observer for event handling

### 4. Code Organization
- Separate configuration from implementation
- Use dependency injection to improve testability
- Implement proper error handling with custom exceptions
- Add appropriate logging at different levels
- Include comprehensive docstrings for all public APIs
- Use constants instead of magic numbers or strings

### 5. Testing
- Write unit tests for all functionality
- Aim for high test coverage (at least 80%)
- Use test fixtures and mocks appropriately
- Test edge cases and error conditions
- Implement integration tests for component interactions

### 6. Performance Considerations
- Be mindful of memory usage
- Avoid unnecessary computations
- Consider asynchronous operations for I/O-bound tasks
- Use appropriate data structures for the task at hand
- Profile code when necessary to identify bottlenecks

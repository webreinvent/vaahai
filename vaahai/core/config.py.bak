"""
Configuration management for Vaahai.

This module handles loading, saving, and accessing configuration from multiple sources
with the following precedence (highest to lowest):
1. CLI arguments
2. Environment variables
3. User-level config file (~/.config/vaahai/config.toml)
4. Project-level config file (.vaahai.toml in project directory)
5. Default values
"""

import os
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Union, Type, get_type_hints, get_origin, get_args

import tomli
import tomli_w
from pydantic import BaseModel, Field, ValidationError

# Constants
DEFAULT_CONFIG_FILENAME = ".vaahai.toml"
ENV_PREFIX = "VAAHAI_"

# Current schema version
CURRENT_SCHEMA_VERSION = 1


class ReviewDepth(str, Enum):
    """Review depth options."""
    QUICK = "quick"
    STANDARD = "standard"
    THOROUGH = "thorough"


class ReviewFocus(str, Enum):
    """Review focus options."""
    ALL = "all"
    SECURITY = "security"
    PERFORMANCE = "performance"
    STYLE = "style"


class OutputFormat(str, Enum):
    """Output format options."""
    TERMINAL = "terminal"
    MARKDOWN = "markdown"
    HTML = "html"


class LLMConfig(BaseModel):
    """LLM configuration settings."""
    provider: str = "openai"
    model: str = "gpt-4"
    api_key: Optional[str] = None
    temperature: float = 0.7
    max_tokens: int = 4000


class ReviewConfig(BaseModel):
    """Review command configuration."""
    depth: ReviewDepth = ReviewDepth.STANDARD
    focus: ReviewFocus = ReviewFocus.ALL
    output_format: OutputFormat = OutputFormat.TERMINAL
    interactive: bool = False
    save_history: bool = False
    private: bool = False


class AnalyzeConfig(BaseModel):
    """Analyze command configuration."""
    tools: List[str] = Field(default_factory=lambda: ["auto"])
    output_format: OutputFormat = OutputFormat.TERMINAL
    include_metrics: bool = True


class DocumentConfig(BaseModel):
    """Document command configuration."""
    style: str = "standard"
    output_format: OutputFormat = OutputFormat.MARKDOWN
    include_examples: bool = True


class ExplainConfig(BaseModel):
    """Explain command configuration."""
    depth: ReviewDepth = ReviewDepth.STANDARD
    output_format: OutputFormat = OutputFormat.TERMINAL
    include_context: bool = True


class VaahaiConfig(BaseModel):
    """Main configuration model."""
    
    # Schema version for backward compatibility
    schema_version: int = CURRENT_SCHEMA_VERSION
    
    llm: LLMConfig = Field(default_factory=LLMConfig)
    review: ReviewConfig = Field(default_factory=ReviewConfig)
    analyze: AnalyzeConfig = Field(default_factory=AnalyzeConfig)
    document: DocumentConfig = Field(default_factory=DocumentConfig)
    explain: ExplainConfig = Field(default_factory=ExplainConfig)
    log_level: str = "info"
    cache_dir: Optional[Path] = None
    custom: Dict[str, Any] = Field(default_factory=dict)
    
    def model_dump(self, **kwargs) -> Dict[str, Any]:
        """Override model_dump to include schema_version."""
        data = super().model_dump(**kwargs)
        data["schema_version"] = CURRENT_SCHEMA_VERSION
        return data


class ConfigManager:
    """
    Configuration manager for Vaahai.
    
    Handles loading, saving, and accessing configuration from multiple sources.
    """
    
    def __init__(self) -> None:
        """Initialize the configuration manager."""
        self._config = VaahaiConfig()
        self._config_sources: Dict[str, str] = {}  # Tracks where each setting came from
        self._loaded = False
        self._initialize_sources()
    
    def _initialize_sources(self) -> None:
        """Initialize the sources tracking dictionary with default values."""
        # Initialize all possible config keys with "default" source
        config_dict = self._config.model_dump()
        flat_config = self._flatten_dict(config_dict)
        
        for key in flat_config.keys():
            self._config_sources[key] = "default"
        
        # Add review.* keys explicitly to ensure they're all tracked
        for field in ReviewConfig.model_fields:
            self._config_sources[f"review.{field}"] = "default"
        
        # Add llm.* keys explicitly
        for field in LLMConfig.model_fields:
            self._config_sources[f"llm.{field}"] = "default"
            
        # Add analyze.* keys explicitly
        for field in AnalyzeConfig.model_fields:
            self._config_sources[f"analyze.{field}"] = "default"
            
        # Add document.* keys explicitly
        for field in DocumentConfig.model_fields:
            self._config_sources[f"document.{field}"] = "default"
            
        # Add explain.* keys explicitly
        for field in ExplainConfig.model_fields:
            self._config_sources[f"explain.{field}"] = "default"
    
    def load(self, cli_args: Optional[Dict[str, Any]] = None) -> None:
        """
        Load configuration from all sources with proper precedence.
        
        Args:
            cli_args: Optional dictionary of CLI arguments to override config
        """
        # Start with default values (already in self._config)
        self._initialize_sources()
        
        # Load from project config file (lowest precedence)
        self._load_from_project_config()
        
        # Load from user config file (overrides project config)
        self._load_from_user_config()
        
        # Load from environment variables (overrides user and project config)
        self._load_from_env()
        
        # Apply CLI arguments (highest precedence)
        if cli_args:
            self._apply_cli_args(cli_args)
        
        self._loaded = True
    
    def _load_from_user_config(self) -> None:
        """Load configuration from user config file."""
        # Resolve user config path dynamically
        user_config_dir = Path(os.environ.get("HOME", str(Path.home()))) / ".config" / "vaahai"
        user_config_file = user_config_dir / "config.toml"
        
        if user_config_file.exists():
            try:
                with open(user_config_file, "rb") as f:
                    config_data = tomli.load(f)
                
                # Check for schema version and migrate if needed
                config_data = self._migrate_schema(config_data, "user config")
                
                self._update_config(config_data, "user config")
            except Exception as e:
                print(f"Error loading user config: {str(e)}")
    
    def _load_from_project_config(self) -> None:
        """Load configuration from project config file."""
        project_config_file = Path(os.getcwd()) / DEFAULT_CONFIG_FILENAME
        if project_config_file.exists():
            try:
                with open(project_config_file, "rb") as f:
                    config_data = tomli.load(f)
                
                # Check for schema version and migrate if needed
                config_data = self._migrate_schema(config_data, "project config")
                
                self._update_config(config_data, "project config")
            except Exception as e:
                print(f"Error loading project config: {str(e)}")
    
    def _migrate_schema(self, config_data: Dict[str, Any], source: str) -> Dict[str, Any]:
        """
        Migrate configuration data from older schema versions to the current version.
        
        Args:
            config_data: Configuration data to migrate
            source: Source of the configuration data
            
        Returns:
            Migrated configuration data
        """
        # Get the schema version from the config data, default to 0 if not present
        schema_version = config_data.get("schema_version", 0)
        
        # If already at current version, no migration needed
        if schema_version == CURRENT_SCHEMA_VERSION:
            return config_data
            
        # Make a copy of the config data to avoid modifying the original
        migrated_data = config_data.copy()
        
        # Apply migrations based on schema version
        if schema_version < 1:
            # Migration from version 0 to 1
            print(f"Migrating {source} from schema version {schema_version} to version 1")
            
            # Example migration: rename old_field to new_field
            if "old_field" in migrated_data:
                migrated_data["new_field"] = migrated_data.pop("old_field")
                
            # Example migration: move nested field to new location
            if "old_section" in migrated_data and "nested_field" in migrated_data["old_section"]:
                if "new_section" not in migrated_data:
                    migrated_data["new_section"] = {}
                migrated_data["new_section"]["new_nested_field"] = migrated_data["old_section"].pop("nested_field")
                
            # Example migration: convert string to enum
            if "review" in migrated_data and "depth" in migrated_data["review"]:
                depth = migrated_data["review"]["depth"]
                if depth == "deep":
                    migrated_data["review"]["depth"] = "thorough"
                    
            # Set the schema version to 1
            migrated_data["schema_version"] = 1
        
        # Add more migrations as needed for future schema versions
        # if schema_version < 2:
        #     # Migration from version 1 to 2
        #     ...
        
        # Set the schema version to the current version
        migrated_data["schema_version"] = CURRENT_SCHEMA_VERSION
        
        return migrated_data
    
    def _load_from_env(self) -> None:
        """Load configuration from environment variables."""
        env_vars = {}
        
        # Process environment variables with VAAHAI_ prefix
        for key, value in os.environ.items():
            if key.startswith(ENV_PREFIX):
                # Convert VAAHAI_LLM_PROVIDER to llm.provider
                config_key = key[len(ENV_PREFIX):].lower().replace("_", ".")
                env_vars[config_key] = value
        
        if env_vars:
            # Convert string values to appropriate types
            processed_env_vars = {}
            for key, value in env_vars.items():
                # Handle enum values
                if key.endswith(".depth"):
                    try:
                        processed_env_vars[key] = ReviewDepth(value)
                    except ValueError:
                        print(f"Invalid depth value in environment: {value}")
                        continue
                elif key.endswith(".focus"):
                    try:
                        processed_env_vars[key] = ReviewFocus(value)
                    except ValueError:
                        print(f"Invalid focus value in environment: {value}")
                        continue
                elif key.endswith(".output_format"):
                    try:
                        processed_env_vars[key] = OutputFormat(value)
                    except ValueError:
                        print(f"Invalid output format in environment: {value}")
                        continue
                elif key.endswith(".interactive") or key.endswith(".save_history") or key.endswith(".private"):
                    processed_env_vars[key] = value.lower() in ("true", "yes", "1", "y")
                else:
                    processed_env_vars[key] = value
            
            # Update config with processed environment variables
            nested_env_vars = self._unflatten_dict(processed_env_vars)
            self._update_config(nested_env_vars, "environment")
    
    def _unflatten_dict(self, flat_dict: Dict[str, Any]) -> Dict[str, Any]:
        """
        Convert a flattened dictionary with dot notation to a nested dictionary.
        
        Args:
            flat_dict: Dictionary with keys using dot notation
            
        Returns:
            Nested dictionary
        """
        result = {}
        
        for key, value in flat_dict.items():
            parts = key.split(".")
            current = result
            
            # Navigate to the right place in the nested dict
            for i, part in enumerate(parts[:-1]):
                if part not in current:
                    current[part] = {}
                current = current[part]
            
            # Set the value
            current[parts[-1]] = value
            
        return result
    
    def _apply_cli_args(self, cli_args: Dict[str, Any]) -> None:
        """
        Apply CLI arguments to the configuration.
        
        Args:
            cli_args: Dictionary of CLI arguments
        """
        # Convert flat CLI args to nested structure
        nested_args = {}
        
        for key, value in cli_args.items():
            if value is None:
                continue
                
            # Skip internal typer args
            if key.startswith("_"):
                continue
                
            # Handle command-specific args
            if "." in key:
                section, option = key.split(".", 1)
                if section not in nested_args:
                    nested_args[section] = {}
                nested_args[section][option] = value
            else:
                # Handle top-level args
                nested_args[key] = value
        
        self._update_config(nested_args, "cli args")
    
    def _update_config(self, new_config: Dict[str, Any], source: str) -> None:
        """
        Update configuration with new values and track their source.
        
        Args:
            new_config: New configuration values
            source: Source of the configuration (e.g., "user config", "environment")
        """
        # Helper function to update nested dictionaries and track sources
        def update_nested(config_dict, update_dict, prefix=""):
            for key, value in update_dict.items():
                full_key = f"{prefix}.{key}" if prefix else key
                
                if isinstance(value, dict) and key in config_dict and key != "custom":
                    # Recursively update nested dictionaries
                    update_nested(config_dict[key], value, full_key)
                else:
                    # Update value and track source
                    if key == "custom" and isinstance(value, dict):
                        # Handle custom section specially
                        if "custom" not in config_dict:
                            config_dict["custom"] = {}
                        for custom_key, custom_value in value.items():
                            config_dict["custom"][custom_key] = custom_value
                            self._config_sources[f"custom.{custom_key}"] = source
                    else:
                        # Only update if the new source has higher precedence than the current source
                        current_source = self._config_sources.get(full_key, "unknown")
                        if self._source_has_higher_precedence(source, current_source):
                            config_dict[key] = value
                            self._config_sources[full_key] = source
        
        # Convert config to dict for updating
        config_dict = self._config.model_dump()
        update_nested(config_dict, new_config)
        
        # Update the config object with the modified dict
        self._config = VaahaiConfig.model_validate(config_dict)
    
    def _source_has_higher_precedence(self, new_source: str, current_source: str) -> bool:
        """
        Determine if a new source has higher precedence than the current source.
        
        Args:
            new_source: New configuration source
            current_source: Current configuration source
            
        Returns:
            True if new source has higher precedence, False otherwise
        """
        # Define precedence order (highest to lowest)
        precedence = [
            "cli args",
            "environment",
            "user config",
            "project config",
            "default",
            "unknown"
        ]
        
        try:
            new_index = precedence.index(new_source)
            current_index = precedence.index(current_source)
            return new_index < current_index
        except ValueError:
            # If source is not in the list, assume lowest precedence
            return False
    
    def get(self, key: str, default: Any = None) -> Any:
        """
        Get a configuration value by key.
        
        Args:
            key: Configuration key using dot notation (e.g., "llm.provider")
            default: Default value if key is not found
            
        Returns:
            Configuration value or default if not found
        """
        if not self._loaded:
            self.load()
            
        # Handle custom section specially
        if key.startswith("custom."):
            _, custom_key = key.split(".", 1)
            return self._config.custom.get(custom_key, default)
            
        # Navigate the nested structure
        value = self._config.model_dump()
        try:
            for part in key.split("."):
                value = value[part]
            return value
        except (KeyError, TypeError):
            return default
    
    def get_source(self, key: str) -> str:
        """
        Get the source of a configuration value.
        
        Args:
            key: Configuration key using dot notation
            
        Returns:
            Source of the configuration value or "unknown"
        """
        return self._config_sources.get(key, "unknown")
    
    def set(self, key: str, value: Any, save: bool = False) -> None:
        """
        Set a configuration value.
        
        Args:
            key: Configuration key using dot notation
            value: Value to set
            save: Whether to save to user config file
            
        Raises:
            ValueError: If the value is invalid for the specified key
        """
        if not self._loaded:
            self.load()
            
        # Handle custom section specially
        if key.startswith("custom."):
            _, custom_key = key.split(".", 1)
            self._config.custom[custom_key] = value
            self._config_sources[key] = "user config"
            
            if save:
                self.save_user_config()
            return
            
        # Validate the value before setting it
        try:
            self._validate_config_value(key, value)
        except ValueError as e:
            raise ValueError(f"Invalid value for '{key}': {str(e)}")
            
        # Convert to dict for updating
        config_dict = self._config.model_dump()
        
        # Navigate to the right place in the nested dict
        parts = key.split(".")
        current = config_dict
        
        # Navigate to the parent of the target key
        for i, part in enumerate(parts[:-1]):
            if part not in current:
                current[part] = {}
            current = current[part]
        
        # Set the value
        current[parts[-1]] = value
        
        # Update the config object and source tracking
        try:
            self._config = VaahaiConfig.model_validate(config_dict)
            self._config_sources[key] = "user config"
        except ValidationError as e:
            raise ValueError(f"Invalid configuration: {str(e)}")
        
        # Save to file if requested
        if save:
            self.save_user_config()
    
    def _validate_config_value(self, key: str, value: Any) -> None:
        """
        Validate a configuration value against its expected type and constraints.
        
        Args:
            key: Configuration key using dot notation
            value: Value to validate
            
        Raises:
            ValueError: If the value is invalid
        """
        # Skip validation for custom section
        if key.startswith("custom."):
            return
            
        # Get the expected type for the key
        parts = key.split(".")
        if len(parts) < 2:
            raise ValueError(f"Invalid configuration key: {key}")
            
        # Find the appropriate model class for the section
        section = parts[0]
        field_name = parts[-1]
        
        # Get the model class for the section
        model_class = None
        if section == "llm":
            model_class = LLMConfig
        elif section == "review":
            model_class = ReviewConfig
        elif section == "analyze":
            model_class = AnalyzeConfig
        elif section == "document":
            model_class = DocumentConfig
        elif section == "explain":
            model_class = ExplainConfig
        elif section == "custom":
            # Custom section doesn't need validation
            return
        else:
            # Check if it's a direct field of VaahaiConfig
            if hasattr(VaahaiConfig, section):
                model_class = VaahaiConfig
                field_name = section
            else:
                raise ValueError(f"Unknown configuration section: {section}")
        
        # For nested fields (e.g., llm.model), navigate to the right model class
        if len(parts) > 2:
            for part in parts[1:-1]:
                field_type = model_class.model_fields[part].annotation
                if hasattr(field_type, "model_fields"):
                    model_class = field_type
                else:
                    raise ValueError(f"Invalid configuration key: {key}")
        
        # Check if the field exists in the model
        if field_name not in model_class.model_fields:
            raise ValueError(f"Unknown configuration field: {field_name}")
            
        # Get the field type
        field = model_class.model_fields[field_name]
        field_type = field.annotation
        
        # Validate enum values
        if isinstance(field_type, type) and issubclass(field_type, Enum):
            if not isinstance(value, str) or value not in [e.value for e in field_type]:
                valid_values = ", ".join([f"'{e.value}'" for e in field_type])
                raise ValueError(f"Value must be one of: {valid_values}")
                
        # Validate boolean values
        elif field_type is bool:
            if not isinstance(value, bool):
                if isinstance(value, str):
                    if value.lower() in ("true", "yes", "1", "on"):
                        return  # Valid boolean string
                    elif value.lower() in ("false", "no", "0", "off"):
                        return  # Valid boolean string
                raise ValueError("Value must be a boolean (true/false)")
                
        # Validate list values
        elif get_origin(field_type) is list:
            if not isinstance(value, list):
                raise ValueError("Value must be a list")
                
        # Validate string values
        elif field_type is str:
            if not isinstance(value, str):
                raise ValueError("Value must be a string")
                
        # Validate integer values
        elif field_type is int:
            if not isinstance(value, int):
                try:
                    int(value)  # Try to convert to int
                except (ValueError, TypeError):
                    raise ValueError("Value must be an integer")
                    
        # Validate float values
        elif field_type is float:
            if not isinstance(value, (int, float)):
                try:
                    float(value)  # Try to convert to float
                except (ValueError, TypeError):
                    raise ValueError("Value must be a number")

    def validate_config(self) -> List[str]:
        """
        Validate the entire configuration and return a list of validation errors.
        
        Returns:
            List of validation error messages, empty if configuration is valid
        """
        errors = []
        
        # Validate each section of the configuration
        try:
            # This will validate the entire configuration
            VaahaiConfig.model_validate(self._config.model_dump())
        except ValidationError as e:
            for error in e.errors():
                loc = ".".join([str(l) for l in error["loc"]])
                errors.append(f"{loc}: {error['msg']}")
                
        return errors

    def save_user_config(self) -> None:
        """Save current configuration to user config file."""
        # Resolve user config path dynamically
        user_config_dir = Path(os.environ.get("HOME", str(Path.home()))) / ".config" / "vaahai"
        user_config_file = user_config_dir / "config.toml"
        
        # Ensure directory exists
        user_config_dir.mkdir(parents=True, exist_ok=True)
        
        # Convert to dict and ensure schema_version is set
        config_dict = self._config.model_dump()
        config_dict["schema_version"] = CURRENT_SCHEMA_VERSION
        
        # Write to file
        with open(user_config_file, "wb") as f:
            tomli_w.dump(config_dict, f)
    
    def init_project_config(self, force: bool = False) -> bool:
        """
        Initialize a project configuration file in the current directory.
        
        Args:
            force: Whether to overwrite existing file
            
        Returns:
            True if file was created, False otherwise
        """
        project_config_file = Path(os.getcwd()) / DEFAULT_CONFIG_FILENAME
        
        if project_config_file.exists() and not force:
            return False
            
        # Create a basic configuration with the current schema version
        config = {
            "schema_version": CURRENT_SCHEMA_VERSION,
            "llm": {
                "provider": "openai",
                "model": "gpt-4",
            },
            "review": {
                "depth": "standard",
                "focus": "all",
            },
        }
        
        # Ensure parent directory exists
        project_config_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Write the configuration
        with open(project_config_file, "wb") as f:
            tomli_w.dump(config, f)
            
        return True
    
    @property
    def config(self) -> VaahaiConfig:
        """Get the full configuration object."""
        if not self._loaded:
            self.load()
        return self._config
    
    def get_all_with_sources(self) -> Dict[str, Dict[str, Union[Any, str]]]:
        """
        Get all configuration values with their sources.
        
        Returns:
            Dictionary mapping keys to dictionaries with 'value' and 'source' keys
        """
        if not self._loaded:
            self.load()
            
        result = {}
        flat_config = self._flatten_dict(self._config.model_dump())
        
        for key, value in flat_config.items():
            result[key] = {
                "value": value,
                "source": self.get_source(key)
            }
            
        # Add custom values
        for key, value in self._config.custom.items():
            full_key = f"custom.{key}"
            result[full_key] = {
                "value": value,
                "source": self.get_source(full_key)
            }
            
        return result
    
    @staticmethod
    def _flatten_dict(d: Dict[str, Any], prefix: str = "") -> Dict[str, Any]:
        """
        Flatten a nested dictionary with dot notation.
        
        Args:
            d: Dictionary to flatten
            prefix: Current key prefix
            
        Returns:
            Flattened dictionary
        """
        result = {}
        
        for key, value in d.items():
            new_key = f"{prefix}.{key}" if prefix else key
            
            if isinstance(value, dict) and key != "custom":
                # Recursively flatten nested dictionaries
                result.update(ConfigManager._flatten_dict(value, new_key))
            else:
                result[new_key] = value
                
        return result


# Global instance
config_manager = ConfigManager()
